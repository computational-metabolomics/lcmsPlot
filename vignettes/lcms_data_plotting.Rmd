---
title: "Easy-to-use, intuitive, and efficient LC-MS data plotting with lcmsPlot"
output:
  BiocStyle::html_document:
    toc: true
    toc_depth: 2  
    number_sections: true  
    toc_float: true
vignette: >
  %\VignetteIndexEntry{basic_plotting}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
bibliography: references.bib
csl: biomed-central.csl
---

```{r setup, include = FALSE}
knitr::opts_knit$set(
  root.dir = dirname(getwd())
)

knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r init, message = FALSE, echo = FALSE, results = "hide"}
library(BiocStyle)
library(xcms)
library(faahKO)
library(MsExperiment)
library(lcmsPlot)
register(SerialParam())
```

# Introduction

LC-MS (or generally X-MS) data visualisation is important when inspecting the quality of the data
as well as during the publication process.
Plots are a quick way to show acquisition anomalies such as retention time shifts,
internal standards inconsistencies, gradual signal drops, and so on.

# Current landscape

The current LC-MS data visualisation landscape is mainly covered by `xcms`'s
base R plotting routines.

Outside `xcms`, many plotting functionalities are tightly coupled specific applications, such as:

- [LCMSQA](https://cran.r-project.org/web/packages/LCMSQA/index.html)
- [MetaboAnalystR](https://www.metaboanalyst.ca/docs/RTutorial.xhtml)
- [CAMERA](https://www.bioconductor.org/packages/release/bioc/html/CAMERA.html)

# Objectives

`lcmsPlot` aims to be a generic, flexible, and interoperable solution for plotting LC-MS data, such
as chromatograms, mass traces, mass spectra, and more.

`lcmsPlot` focuses on the following objectives:

- Generic and flexible plotting capabilities.
- Easy-to-use programming interface using a building-blocks approach such as [ggplot](https://ggplot2.tidyverse.org/).
- Interoperability: it can be seamlessly used with `xcms` or raw data (e.g., from mzML).
- Efficiency: better performance when scaling, compared to current solutions.

# Installation

`lcmsPlot` is a Bioconductor package and to install it we have to use [BiocManager](https://cran.r-project.org/web/packages/BiocManager/index.html).

```{r, eval=FALSE}
if (!requireNamespace("BiocManager", quietly = TRUE))
    install.packages("BiocManager")
BiocManager::install("lcmsPlot")
```

# Load data

For demonstration purpose we will analyse a small subset of the
data from [@Saghatelian04] in which the metabolic consequences of the knock-out
of the fatty acid amide hydrolase (FAAH) gene in mice was investigated (same data as in the [xcms vignette](https://www.bioconductor.org/packages/devel/bioc/vignettes/xcms/inst/doc/xcms.html)).


```{r load-data, message=FALSE}
library(xcms)
library(faahKO)
library(MsExperiment)
library(patchwork)
library(lcmsPlot)

cdfs <- dir(system.file("cdf", package = "faahKO"), full.names = TRUE,
            recursive = TRUE)[c(1, 2, 5, 6, 7, 8, 11, 12)]

sample_names <- sub(basename(cdfs), pattern = ".CDF", replacement = "", fixed = TRUE)

pd <- data.frame(sample_name = sample_names,
                 sample_group = c(rep("KO", 4), rep("WT", 4)),
                 stringsAsFactors = FALSE)

faahko <- readMsExperiment(spectraFiles = cdfs, sampleData = pd)
faahko
```

# Samples summary

Before examining the detected peaks and their chromatograms, we will first gain an overview of the study samples using a series of plots that highlight different aspects of the data.

## Plot base peak chromatogram (BPC)

Base peak chromatograms (BPCs) are useful in LC-MS because they simplify complex data and help quickly identify the most intense signals.

In the example below we plot the BPC for the eight samples:

```{r}
lcmsPlot(faahko, sample_id_column = "sample_name") +
  chromatogram(ppm = 5, rt_tol = 10, aggregation_fun = "max") +
  facets(facets = "sample_name", ncol = 4)
```

We can also plot multiple chromatograms in the same plot:

```{r}
lcmsPlot(faahko, sample_id_column = "sample_name") +
  chromatogram(ppm = 5, rt_tol = 10, aggregation_fun = "max") +
  arrange(group_by = "sample_group") +
  labels(title = "Base peak chromatograms", legend = "Sample group") +
  legend(position = "bottom")
```

## Plot total ion chromatogram (TIC)

Total ion chromatogram (TIC) plots the sum of all ion intensities detected at each time point, giving a complete picture of everything entering the detector; not just the most abundant ion.

```{r}
lcmsPlot(faahko, sample_id_column = "sample_name") +
  chromatogram(ppm = 5, rt_tol = 10, aggregation_fun = "sum") +
  facets(facets = "sample_name", ncol = 4)
```

## Total ion current

```{r}
lcmsPlot(faahko, sample_id_column = "sample_name") +
  total_ion_current(type = "violin") +
  arrange(group_by = "sample_group") +
  labels(title = "Total ion current", legend = "Sample group")
```

## Intensity maps

2D intensity maps are a quick way to see patterns in the acquired data.

Below, we build intensity density maps from two samples:

```{r}
lcmsPlot(faahko, sample_id_column = "sample_name", parallel_param = MulticoreParam(workers = 2)) +
  intensity_map(sample_ids = c("ko15", "wt15"), mz_range = c(200, 600), rt_range = c(4200, 4500), density = TRUE) +
  facets(facets = "sample_id", ncol = 2)
```

# Plot chromatograms

To begin, we'll perform peak detection to enable highlighting of detected peaks in the chromatogram plots, while retaining the option to plot chromatograms directly from the raw data.

```{r}
cwp <- CentWaveParam(peakwidth = c(20, 80), noise = 5000, prefilter = c(6, 5000))
faahko <- findChromPeaks(faahko, param = cwp)
```

Next, we will plot chromatograms for a feature detected by `xcms` in all considered samples.

```{r}
lcmsPlot(faahko, sample_id_column = "sample_name") +
  chromatogram(features = rbind(c(mzmin = 334.9, mzmax = 335.1, rtmin = 2700, rtmax = 2900))) +
  arrange(group_by = "sample_group") +
  labels(legend = "Sample group")
```

The above plot can be faceted on metadata factors; in this case we facet on `feature_id` and `sample_id`:

```{r}
lcmsPlot(faahko, sample_id_column = "sample_name") +
  chromatogram(
    features = rbind(c(mzmin = 334.9, mzmax = 335.1, rtmin = 2700, rtmax = 2900)),
    highlight_peaks = TRUE,
    highlight_peaks_color = "#121212",
    highlight_apices = list(top_n = 1)
  ) +
  facets(facets = c('feature_id', 'sample_id'), ncol = 4) +
  labels(legend = "Sample") +
  legend(position = "bottom")
```

Moreover, with the `highlight_apices` option, we highlighted the apex with its RT value.

On the other hand, gridded plots (`grid` function), arrange panels in a matrix defined by two variables, allowing structured comparisons across both dimensions.

```{r}
lcmsPlot(faahko, sample_id_column = 'sample_name') +
  chromatogram(
    features = rbind(
      c(mzmin = 334.9, mzmax = 335.1, rtmin = 2700, rtmax = 2900),
      c(mzmin = 278.99721, mzmax = 279.00279, rtmin = 2740, rtmax = 2840)
    ),
    highlight_peaks = TRUE,
    highlight_peaks_color = '#f00') +
  grid(rows = 'feature_id', cols = 'sample_id', free_y = TRUE)
```

In some cases, you may want to highlight specific regions of the extracted ion chromatogram, for example, to draw attention to a peak that hasn't been detected yet. This can be done using the `rt_line` functionality:

```{r}
lcmsPlot(faahko, sample_id_column = 'sample_name') +
  chromatogram(features = rbind(c(mzmin = 334.9, mzmax = 335.1, rtmin = 2700, rtmax = 2900))) +
  facets(facets = 'sample_id', ncol = 4) +
  rt_line(intercept = 2800, line_type = 'solid', color = 'red') +
  rt_line(intercept = 2750, line_type = 'dashed', color = 'blue') +
  rt_line(intercept = 2850, line_type = 'dashed', color = 'blue')
```

# Plot retention time alignment effect

Next, let’s explore some plots that illustrate the effect of retention time alignment.

First, we’ll perform the retention time alignment/adjustment:

```{r}
faahko <- adjustRtime(faahko, param = ObiwarpParam(binSize = 0.6))
```

Now, we can visualise the BPC for the raw and corrected datasets:

```{r}
bpc <- lcmsPlot(faahko, sample_id_column = "sample_name") +
  chromatogram(ppm = 5, rt_tol = 10, aggregation_fun = "max") +
  arrange(group_by = "sample_group") +
  labels(legend = "Sample group") +
  legend(position = "bottom") +
  get_plot()

bpc_rt_adjusted <- lcmsPlot(faahko, sample_id_column = "sample_name") +
  chromatogram(ppm = 5, rt_tol = 10, aggregation_fun = "max", rt_adjusted = TRUE) +
  arrange(group_by = "sample_group") +
  labels(legend = "Sample group") +
  legend(position = "bottom") +
  get_plot()

(bpc[[1]] / bpc_rt_adjusted[[1]]) +
  plot_layout(guides = "collect", axes = "collect") &
  ggplot2::theme(legend.position = "bottom")
```

The following plot visualises the retention time correction applied during alignment: the x-axis shows the adjusted retention time (`rt_adj`), while the y-axis displays the difference between the raw and adjusted retention times (`rt_raw - rt_adj`). This highlights how much each feature's retention time was shifted to achieve alignment across samples.
Smooth, gradual trends in the plot indicate consistent chromatographic drift correction, while abrupt changes may suggest anomalies.
This diagnostic view helps you assess the quality and extent of retention time alignment in LC-MS data processing.

```{r}
lcmsPlot(faahko, sample_id_column = "sample_name") +
  rt_diff_plot() +
  arrange(group_by = "sample_group") +
  labels(legend = "Sample group")
```

# Plot grouped peaks across samples (features)

The next step in LC-MS preprocessing is grouping signals/peaks across samples.

```{r}
pdp <- PeakDensityParam(
  sampleGroups = sampleData(faahko)$sample_group,
  minFraction = 0.4,
  bw = 30)
faahko <- groupChromPeaks(faahko, param = pdp)
```

Grouped peaks are assigned unique IDs based on their m/z values and retention times.
These IDs can then be used to automatically plot the chromatograms of individual peaks across samples.

```{r}
lcmsPlot(faahko, sample_id_column = 'sample_name') +
  chromatogram(
    features = c('M205T2792', 'M207T2719', 'M279T2791', 'M284T2719'),
    ppm = 10,
    rt_tol = 80,
    highlight_peaks = TRUE,
    highlight_peaks_factor = "sample_group") +
  arrange(group_by = 'sample_group') +
  facets(facets = 'feature_id', ncol = 2, free_x = TRUE, free_y = TRUE) +
  labels(title = "Feature M205T2792", legend = "Sample") +
  legend(position = "bottom")
```

# Plot chromatograms with mass traces

Until now, we've primarily focused on chromatograms to understand the abundance and retention behaviour of features across samples.
These chromatograms show when and how strongly a compound elutes, but they don't reveal whether the mass accuracy or consistency is stable across the peak or between samples; this is where the mass trace (bottom panel) becomes valuable.

```{r}
lcmsPlot(faahko, sample_id_column = 'sample_name') +
  chromatogram(
    features = 'M205T2792',
    sample_ids = c('ko15', 'ko16', 'wt15', 'wt16'),
    ppm = 10,
    rt_tol = 50,
    highlight_peaks = TRUE) +
  mass_trace() +
  arrange(group_by = 'sample_id') +
  labels(title = "Feature M205T2792", legend = "Sample") +
  legend(position = "bottom")
```

As for plain chromatograms, we can facet a combination of chromatograms + mass traces on a factor, such as `feature_id`:

```{r}
lcmsPlot(faahko, sample_id_column = 'sample_name') +
  chromatogram(
    features = c('M283T3890', 'M205T2792'),
    sample_ids = c('ko15', 'ko16', 'wt15', 'wt16'),
    ppm = 10,
    rt_tol = 50,
    highlight_peaks = TRUE) +
  mass_trace() +
  arrange(group_by = "sample_id") +
  facets(facets = 'feature_id', ncol = 2) +
  labels(legend = "Sample") +
  legend(position = "bottom")
```

Or multiple factors (`feature_id` and `sample_id`):

```{r, fig.height=8, fig.width=5}
lcmsPlot(faahko, sample_id_column = 'sample_name') +
  chromatogram(
    features = c('M283T3890', 'M205T2792'),
    sample_ids = c('ko15', 'ko16', 'wt15', 'wt16'),
    ppm = 10,
    rt_tol = 50,
    highlight_peaks = TRUE,
    highlight_peaks_color = '#343434') +
  mass_trace() +
  facets(facets = c('feature_id', 'sample_id'))
```

# Plot chromatograms from raw files

Until now, we’ve been using an `MsExperiment` object as our data source. However, `lcmsPlot` also supports extracting chromatograms directly from raw files, such as those in the `mzML` format.

```{r}
raw_files <- faahko@sampleData$spectraOrigin[1:4]

lcmsPlot(raw_files) +
  chromatogram(features = rbind(c(mzmin = 334.9, mzmax = 335.1, rtmin = 2700, rtmax = 2900))) +
  arrange(group_by = "sample_id") +
  legend(position = "bottom") +
  labels(legend = "Sample")
```

Metadata can be attached to the raw files and used for plotting as follows:

```{r}
raw_files <- faahko@sampleData$spectraOrigin[c(1, 2, 5, 6)]

metadata <- data.frame(
  sample_type = c("KO", "KO", "WT", "WT"),
  sample_id = c("S1", "S2", "S3", "S4")
)

lcmsPlot(raw_files, sample_id_column = "sample_id", metadata = metadata) +
  chromatogram(
    features = rbind(
      c(mzmin = 334.9, mzmax = 335.1, rtmin = 2700, rtmax = 2900),
      c(mzmin = 278.99721, mzmax = 279.00279, rtmin = 2740, rtmax = 2840)
    )
  ) +
  grid(rows = 'feature_id', cols = 'sample_type', free_y = TRUE)
```

# Plot spectra

Now, we want to include spectra because they provide critical compositional insight into what ions make up the feature at a given point in time.

To do so, we can use the `spectra` function and define what mode of scan selection to use.

## Select closest scan to specified RT

To select the closest scan to a specified RT value you can use `mode = "closest"`:

```{r}
lcmsPlot(faahko, sample_id_column = 'sample_name') +
  chromatogram(
    features = 'M283T3890',
    sample_ids = 'ko15',
    ppm = 5,
    rt_tol = 50,
    highlight_peaks = TRUE) +
  spectra(rt = 3860, mode = "closest", ms_level = 1) +
  labels(title = "Feature M283T3890", legend = "Sample") +
  legend(position = "bottom")
```

## Select scan closest to a detected peak apex

To select the closest scan to a detected peak apex you can use `mode = "closest_apex"`:

```{r, fig.height=3}
lcmsPlot(faahko, sample_id_column = 'sample_name') +
  chromatogram(
    features = rbind(
      c(mzmin = 334.9, mzmax = 335.1, rtmin = 2700, rtmax = 2900),
      c(mzmin = 278.99721, mzmax = 279.00279, rtmin = 2740, rtmax = 2840)
    ),
    sample_ids = 'ko15',
    highlight_peaks = TRUE) +
  spectra(mode = "closest_apex", ms_level = 1) +
  facets(facets = "feature_id", ncol = 2) +
  labels(legend = "Sample") +
  legend(position = "bottom") +
  layout(design = "C\nS\nS")
```

## Select multiple scans across a detected peak

To select multiple scans across a detected peak, given an RT interval, you can use `mode = "across_peak"`:

```{r, fig.height=5, fig.width=3}
lcmsPlot(faahko, sample_id_column = 'sample_name') +
  chromatogram(
    features = "M205T2792",
    sample_ids = 'ko15',
    ppm = 5,
    rt_tol = 50,
    highlight_peaks = TRUE) +
  spectra(mode = "across_peak", interval = 10, ms_level = 1) +
  labels(legend = "Sample") +
  legend(position = "bottom") +
  layout(design = "C\nS\nS\nS\nS\nS\nS\nS")
```

## Plot standalone spectra

So far we have been plotting spectra alongside chromatograms.
Often, it is preferable to plot spectra on their own to allow for clearer analysis of spectral features:

```{r}
lcmsPlot(faahko, sample_id_column = 'sample_name') +
  spectra(
    sample_ids = c('ko15', 'wt15'),
    rt = 2740,
    mode = "closest",
    ms_level = 1) +
  legend(position = "bottom")
```
