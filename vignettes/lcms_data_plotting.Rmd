---
title: "Easy-to-use, intuitive, and efficient LC-MS data plotting with lcmsPlot"
output:
  BiocStyle::html_document:
    toc: true
    toc_depth: 2  
    number_sections: true  
    toc_float: true
vignette: >
  %\VignetteIndexEntry{basic_plotting}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
bibliography: references.bib
csl: biomed-central.csl
---

```{r setup, include = FALSE}
knitr::opts_knit$set(
  root.dir = dirname(getwd())
)

knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r init, message = FALSE, echo = FALSE, results = "hide"}
library(BiocStyle)
library(faahKO)
library(MsExperiment)
library(lcmsPlot)

BiocParallel::register(BiocParallel::SerialParam())
```

# Introduction

Visualisation of LC-MS (and more generally X-MS) data is essential for both quality control and communication of results. Plots help reveal acquisition issues such as retention time shifts, internal standard inconsistencies, or signal drifts, and they provide clear figures for publications.

Most LC-MS visualisation currently relies on:

- xcms: base R plotting routines that cover common needs but offer limited flexibility and aesthetics.
- Other tools (LCMSQA, MetaboAnalystR, CAMERA): provide plotting but are tightly coupled to specific workflows, reducing general usability.
- Custom plotting using ggplot2: requires knowledge of ggplot2 and for advanced usage it is less intuitive.

Overall, existing options are either too specialised or too rigid for flexible, cross-platform use.

## Objectives

`lcmsPlot` aims to provide a modern, generic solution for LC-MS visualisation, focused on:

- Flexible plotting: chromatograms, mass traces, spectra, and more.
- Building-blocks design: [ggplot](https://ggplot2.tidyverse.org/)-like interface for customisable, reproducible plots.
- Interoperability: works seamlessly with xcms outputs or raw formats (e.g., mzML).
- Efficiency: scales better to large datasets than current solutions.

The goal is for `lcmsPlot` to become the community standard for LC-MS data visualisation: versatile for exploration, efficient for large studies, and capable of producing publication-ready figures with minimal effort.

# Installation

`lcmsPlot` is a Bioconductor package and to install it we have to use [BiocManager](https://cran.r-project.org/web/packages/BiocManager/index.html).

```{r, eval=FALSE}
if (!requireNamespace("BiocManager", quietly = TRUE))
    install.packages("BiocManager")
BiocManager::install("lcmsPlot")
```

# Load data

For demonstration purpose we will analyse a small subset of the
data from [@Saghatelian04] in which the metabolic consequences of the knock-out
of the fatty acid amide hydrolase (FAAH) gene in mice was investigated (same data as in the [xcms vignette](https://www.bioconductor.org/packages/devel/bioc/vignettes/xcms/inst/doc/xcms.html)).


```{r load-data, message=FALSE}
library(faahKO)
library(MsExperiment)
library(patchwork)
library(lcmsPlot)

# Making sure that these functions are from the lcmsPlot library
chromatogram <- lcmsPlot::chromatogram
spectra <- lcmsPlot::spectra

cdfs <- dir(system.file("cdf", package = "faahKO"), full.names = TRUE,
            recursive = TRUE)[c(1, 2, 5, 6, 7, 8, 11, 12)]

sample_names <- sub(basename(cdfs), pattern = ".CDF", replacement = "", fixed = TRUE)

pd <- data.frame(sample_name = sample_names,
                 sample_group = c(rep("KO", 4), rep("WT", 4)),
                 stringsAsFactors = FALSE)

faahko <- readMsExperiment(spectraFiles = cdfs, sampleData = pd)
faahko
```

# Samples summary

Before examining the detected peaks and their chromatograms, we will first gain an overview of the study samples using a series of plots that highlight different aspects of the data.

## Plot base peak chromatogram (BPC)

Base peak chromatograms (BPCs) are useful in LC-MS because they simplify complex data and help quickly identify the most intense signals.

In the example below we plot the BPC for the eight samples:

```{r}
lcmsPlot(faahko, sample_id_column = "sample_name") +
  chromatogram(ppm = 5, rt_tol = 10, aggregation_fun = "max") +
  facets(facets = "sample_name", ncol = 4)
```

We can also plot multiple chromatograms in the same plot:

```{r}
lcmsPlot(faahko, sample_id_column = "sample_name") +
  chromatogram(ppm = 5, rt_tol = 10, aggregation_fun = "max") +
  arrange(group_by = "sample_group") +
  labels(title = "Base peak chromatograms", legend = "Sample group") +
  legend(position = "bottom")
```

## Plot total ion chromatogram (TIC)

Total ion chromatogram (TIC) plots the sum of all ion intensities detected at each time point, giving a complete picture of everything entering the detector; not just the most abundant ion.

```{r}
lcmsPlot(faahko, sample_id_column = "sample_name") +
  chromatogram(ppm = 5, rt_tol = 10, aggregation_fun = "sum") +
  facets(facets = "sample_name", ncol = 4)
```

## Total ion current

```{r}
lcmsPlot(faahko, sample_id_column = "sample_name") +
  total_ion_current(type = "violin") +
  arrange(group_by = "sample_group") +
  labels(title = "Total ion current", legend = "Sample group")
```

## Intensity maps

2D intensity maps are a quick way to see patterns in the acquired data.

Below, we build intensity density maps from two samples:

```{r}
lcmsPlot(faahko, sample_id_column = "sample_name", parallel_param = MulticoreParam(workers = 2)) +
  intensity_map(sample_ids = c("ko15", "wt15"), mz_range = c(200, 600), rt_range = c(4200, 4500), density = TRUE) +
  facets(facets = "sample_id", ncol = 2)
```

# Plot chromatograms

To begin, we'll perform peak detection to enable highlighting of detected peaks in the chromatogram plots, while retaining the option to plot chromatograms directly from the raw data.

```{r}
cwp <- xcms::CentWaveParam(peakwidth = c(20, 80), noise = 5000, prefilter = c(6, 5000))
faahko <- xcms::findChromPeaks(faahko, param = cwp)
```

Next, we will plot chromatograms for a feature detected by `xcms` in all considered samples.

```{r}
lcmsPlot(faahko, sample_id_column = "sample_name") +
  chromatogram(features = rbind(c(mzmin = 334.9, mzmax = 335.1, rtmin = 2700, rtmax = 2900))) +
  arrange(group_by = "sample_group") +
  labels(legend = "Sample group")
```

The above plot can be faceted on metadata factors; in this case we facet on `feature_id` and `sample_id`:

```{r}
lcmsPlot(faahko, sample_id_column = "sample_name") +
  chromatogram(
    features = rbind(c(mzmin = 334.9, mzmax = 335.1, rtmin = 2700, rtmax = 2900)),
    highlight_peaks = TRUE,
    highlight_peaks_color = "#121212",
    highlight_apices = list(top_n = 1)
  ) +
  facets(facets = c('feature_id', 'sample_id'), ncol = 4) +
  labels(legend = "Sample") +
  legend(position = "bottom")
```

Moreover, with the `highlight_apices` option, we highlighted the apex with its RT value.

On the other hand, gridded plots (`grid` function), arrange panels in a matrix defined by two variables, allowing structured comparisons across both dimensions.

```{r}
lcmsPlot(faahko, sample_id_column = 'sample_name') +
  chromatogram(
    features = rbind(
      c(mzmin = 334.9, mzmax = 335.1, rtmin = 2700, rtmax = 2900),
      c(mzmin = 278.99721, mzmax = 279.00279, rtmin = 2740, rtmax = 2840)
    ),
    highlight_peaks = TRUE,
    highlight_peaks_color = '#f00') +
  grid(rows = 'feature_id', cols = 'sample_id', free_y = TRUE)
```

In some cases, you may want to highlight specific regions of the extracted ion chromatogram, for example, to draw attention to a peak that hasn't been detected yet. This can be done using the `rt_line` functionality:

```{r}
lcmsPlot(faahko, sample_id_column = 'sample_name') +
  chromatogram(features = rbind(c(mzmin = 334.9, mzmax = 335.1, rtmin = 2700, rtmax = 2900))) +
  facets(facets = 'sample_id', ncol = 4) +
  rt_line(intercept = 2800, line_type = 'solid', color = 'red') +
  rt_line(intercept = 2750, line_type = 'dashed', color = 'blue') +
  rt_line(intercept = 2850, line_type = 'dashed', color = 'blue')
```

# Plot retention time alignment effect

Next, let’s explore some plots that illustrate the effect of retention time alignment.

First, we’ll perform the retention time alignment/adjustment:

```{r}
faahko <- xcms::adjustRtime(faahko, param = ObiwarpParam(binSize = 0.6))
```

Now, we can visualise the BPC for the raw and corrected datasets:

```{r}
bpc <- lcmsPlot(faahko, sample_id_column = "sample_name") +
  chromatogram(ppm = 5, rt_tol = 10, aggregation_fun = "max") +
  arrange(group_by = "sample_group") +
  labels(legend = "Sample group") +
  legend(position = "bottom") +
  get_plot()

bpc_rt_adjusted <- lcmsPlot(faahko, sample_id_column = "sample_name") +
  chromatogram(ppm = 5, rt_tol = 10, aggregation_fun = "max", rt_adjusted = TRUE) +
  arrange(group_by = "sample_group") +
  labels(legend = "Sample group") +
  legend(position = "bottom") +
  get_plot()

(bpc[[1]] / bpc_rt_adjusted[[1]]) +
  plot_layout(guides = "collect", axes = "collect") &
  ggplot2::theme(legend.position = "bottom")
```

The following plot visualises the retention time correction applied during alignment: the x-axis shows the adjusted retention time (`rt_adj`), while the y-axis displays the difference between the raw and adjusted retention times (`rt_raw - rt_adj`). This highlights how much each feature's retention time was shifted to achieve alignment across samples.
Smooth, gradual trends in the plot indicate consistent chromatographic drift correction, while abrupt changes may suggest anomalies.
This diagnostic view helps you assess the quality and extent of retention time alignment in LC-MS data processing.

```{r}
lcmsPlot(faahko, sample_id_column = "sample_name") +
  rt_diff_plot() +
  arrange(group_by = "sample_group") +
  labels(legend = "Sample group")
```

# Plot grouped peaks across samples (features)

The next step in LC-MS preprocessing is grouping signals/peaks across samples.

```{r}
pdp <- xcms::PeakDensityParam(
  sampleGroups = sampleData(faahko)$sample_group,
  minFraction = 0.4,
  bw = 30)
faahko <- xcms::groupChromPeaks(faahko, param = pdp)
```

Grouped peaks are assigned unique IDs based on their m/z values and retention times.
These IDs can then be used to automatically plot the chromatograms of individual peaks across samples.

```{r}
lcmsPlot(faahko, sample_id_column = 'sample_name') +
  chromatogram(
    features = c('M205T2792', 'M207T2719', 'M279T2791', 'M284T2719'),
    ppm = 10,
    rt_tol = 80,
    highlight_peaks = TRUE,
    highlight_peaks_factor = "sample_group") +
  arrange(group_by = 'sample_group') +
  facets(facets = 'feature_id', ncol = 2, free_x = TRUE, free_y = TRUE) +
  labels(title = "Feature M205T2792", legend = "Sample") +
  legend(position = "bottom")
```

# Plot chromatograms with mass traces

Until now, we've primarily focused on chromatograms to understand the abundance and retention behaviour of features across samples.
These chromatograms show when and how strongly a compound elutes, but they don't reveal whether the mass accuracy or consistency is stable across the peak or between samples; this is where the mass trace (bottom panel) becomes valuable.

```{r}
lcmsPlot(faahko, sample_id_column = 'sample_name') +
  chromatogram(
    features = 'M205T2792',
    sample_ids = c('ko15', 'ko16', 'wt15', 'wt16'),
    ppm = 10,
    rt_tol = 50,
    highlight_peaks = TRUE) +
  mass_trace() +
  arrange(group_by = 'sample_id') +
  labels(title = "Feature M205T2792", legend = "Sample") +
  legend(position = "bottom")
```

As for plain chromatograms, we can facet a combination of chromatograms + mass traces on a factor, such as `feature_id`:

```{r}
lcmsPlot(faahko, sample_id_column = 'sample_name') +
  chromatogram(
    features = c('M283T3890', 'M205T2792'),
    sample_ids = c('ko15', 'ko16', 'wt15', 'wt16'),
    ppm = 10,
    rt_tol = 50,
    highlight_peaks = TRUE) +
  mass_trace() +
  arrange(group_by = "sample_id") +
  facets(facets = 'feature_id', ncol = 2) +
  labels(legend = "Sample") +
  legend(position = "bottom")
```

Or multiple factors (`feature_id` and `sample_id`):

```{r, fig.height=12, fig.width=6}
lcmsPlot(faahko, sample_id_column = 'sample_name') +
  chromatogram(
    features = c('M283T3890', 'M205T2792'),
    sample_ids = c('ko15', 'ko16', 'wt15', 'wt16'),
    ppm = 10,
    rt_tol = 50,
    highlight_peaks = TRUE,
    highlight_peaks_color = '#343434') +
  mass_trace() +
  facets(facets = c('feature_id', 'sample_id'))
```

# Plot chromatograms from raw files

Until now, we’ve been using an `MsExperiment` object as our data source. However, `lcmsPlot` also supports extracting chromatograms directly from raw files, such as those in the `mzML` format.

```{r}
raw_files <- faahko@sampleData$spectraOrigin[1:4]

lcmsPlot(raw_files) +
  chromatogram(features = rbind(c(mzmin = 334.9, mzmax = 335.1, rtmin = 2700, rtmax = 2900))) +
  arrange(group_by = "sample_id") +
  legend(position = "bottom") +
  labels(legend = "Sample")
```

Metadata can be attached to the raw files and used for plotting as follows:

```{r}
raw_files <- faahko@sampleData$spectraOrigin[c(1, 2, 5, 6)]

metadata <- data.frame(
  sample_type = c("KO", "KO", "WT", "WT"),
  sample_id = c("S1", "S2", "S3", "S4")
)

lcmsPlot(raw_files, sample_id_column = "sample_id", metadata = metadata) +
  chromatogram(
    features = rbind(
      c(mzmin = 334.9, mzmax = 335.1, rtmin = 2700, rtmax = 2900),
      c(mzmin = 278.99721, mzmax = 279.00279, rtmin = 2740, rtmax = 2840)
    )
  ) +
  grid(rows = 'feature_id', cols = 'sample_type', free_y = TRUE)
```

# Plot spectra

Now, we want to include spectra because they provide critical compositional insight into what ions make up the feature at a given point in time.

To do so, we can use the `spectra` function and define what mode of scan selection to use.

## Select closest scan to specified RT

To select the closest scan to a specified RT value you can use `mode = "closest"`:

```{r}
lcmsPlot(faahko, sample_id_column = 'sample_name') +
  chromatogram(
    features = 'M283T3890',
    sample_ids = 'ko15',
    ppm = 5,
    rt_tol = 50,
    highlight_peaks = TRUE) +
  spectra(rt = 3860, mode = "closest", ms_level = 1) +
  labels(title = "Feature M283T3890", legend = "Sample") +
  legend(position = "bottom")
```

## Select scan closest to a detected peak apex

To select the closest scan to a detected peak apex you can use `mode = "closest_apex"`:

```{r, fig.height=10}
lcmsPlot(faahko, sample_id_column = 'sample_name') +
  chromatogram(
    features = rbind(
      c(mzmin = 334.9, mzmax = 335.1, rtmin = 2700, rtmax = 2900),
      c(mzmin = 278.99721, mzmax = 279.00279, rtmin = 2740, rtmax = 2840)
    ),
    sample_ids = 'ko15',
    highlight_peaks = TRUE) +
  spectra(mode = "closest_apex", ms_level = 1) +
  facets(facets = "feature_id", ncol = 2) +
  labels(legend = "Sample") +
  legend(position = "bottom") +
  layout(design = "C\nS\nS")
```

## Select multiple scans across a detected peak

To select multiple scans across a detected peak, given an RT interval, you can use `mode = "across_peak"`:

```{r, fig.height=10, fig.width=5}
lcmsPlot(faahko, sample_id_column = 'sample_name') +
  chromatogram(
    features = "M205T2792",
    sample_ids = 'ko15',
    ppm = 5,
    rt_tol = 50,
    highlight_peaks = TRUE) +
  spectra(mode = "across_peak", interval = 10, ms_level = 1) +
  labels(legend = "Sample") +
  legend(position = "bottom") +
  layout(design = "C\nS\nS\nS\nS\nS\nS\nS")
```

## Plot standalone spectra

So far we have been plotting spectra alongside chromatograms.
Often, it is preferable to plot spectra on their own to allow for clearer analysis of spectral features:

```{r}
lcmsPlot(faahko, sample_id_column = 'sample_name') +
  spectra(
    sample_ids = c('ko15', 'wt15'),
    rt = 2740,
    mode = "closest",
    ms_level = 1) +
  legend(position = "bottom")
```

# Session Info

```{r}
sessionInfo()
```
